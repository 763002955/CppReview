# 排序算法总结

冒泡排序

归并排序

快速排序

#### 堆排序

完全二叉树：除了最后一层之外的其他每一层都被完全填充，并且所有结点都保持向**左对齐**，简单来说就是每一层都是从左往右填，只有最后一层**可以**不填满

```
Q:数组如何转换为一个完全二叉树，怎么找到父节点/子节点？
下标i 左孩子下标2*i+1 右孩子下标2*i+2
下标i 父节点下标 (i-1)/2
```

大根堆：完全二叉树，子节点的值都小于父节点的值，每棵子树的最大值都是这个子树的头结点，左右子树之间没有确定的大小关系

小根堆：与大根堆相反

**大根堆的建立**：

```
遍历数组，对于每个下标，找到其现在的父节点（下标(i-1)/2）。对比大小，若大就数组内交换这两个数，直至父节点大于该数。

举例说明：

数组：5，7，0，6，8
将5作为父节点，从7开始遍历，7的父节点为nums[0]=5<7,交换nums[0]和nums[1],数组变为7，5，0，6，8
遍历到0，0的父节点为nums[0]=7>0
遍历到6，6父节点为nums[(3-1)/2]=5<6,6，5交换后，6的父节点为nums[0]=7>6
遍历到8，8父节点为nums[1]=6<8,6，8交换后，nums[1]=8>父节点nums[0]=7,所以7，8交换
最终得到大根堆8，7，0，5，6

```

此处的大根堆是无序的。

**将大根堆排至有序**：

```
建立大根堆后，把堆顶元素和最后一个元素交换，然后size-1，从下标为0开始，父节点与孩子的最大值对比，若父<孩子最大值，则交换。

举例说明：

上个例子中，得到大根堆8，7，0，5，6
首先，8是全局最大值，将8与6交换，并且size-1，即下一次对数组处理时忽略已经确定的最大值8(此时排在队尾)
对于6，7，0，5，从6开始对比6与其2孩子的最大值7，7>6，所以交换6，7，数组变为7，6，0，5
此时6位于nums[1]位置，对比6与其1孩子5，不用动
此时7是最大值，和5交换，size-1，需要处理的数组变为5，6，0，(7，8)
继续上述操作，直到得出结果0，5，6，7，8

```



例题：要求返回数组的最大值/返回最大值并弹出