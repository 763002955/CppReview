# C++左值引用和右值引用

**左值**是可以放在赋值号左边被赋值的值；左值必须要在内存中有实体；
**右值**是在赋值号右边取出值赋给其他变量的值；右值可以在内存也可以在CPU寄存器。

左值是指表达式结束后依然存在的*持久化对象*，右值是指表达式结束时就不再存在的*临时对象*。

 **一个对象被用作右值时，使用的是它的内容(值)，被当作左值时，使用的是它的地址。**

所有的具名变量或者对象都是左值，而右值不具名。很难得到左值和右值的真正定义，但是有一个可以区分左值和右值的便捷方法：**看能不能对表达式取地址，如果能，则为左值，否则为右值**。

**引用：**别名，一个变量可以有多个引用，引用必须初始化，引用只能在初始化的时候引用一次，不能更改引用其他变量。对引用的一切操作，就相当于对原对象的操作。



### 左值引用

**通过&获得左值引用**，左值引用只能绑定左值。

```
type &引用名 = 左值表达式；
```

```
int intValue1 = 10;
//将intValue1绑定到intValue2和intValue3
int &intValue2 = intValue1, &intValue3 = intValue2;
```

不能将左值引用绑定到一个右值，但是const的左值引用可以，常量引用不能修改绑定对象的值

```
int &intValue1 = 10;//错误
const int &intValue2 = 10;//正确
```



### 右值引用

右值一般指的是表示式中的临时变量，在c++中临时变量在表达式结束后就被销毁了，之后程序就无法再引用这个变量了。但是c++11提供了一个方法，让我们可以引用这个临时变量。这个方法就是所谓的右值引用。

**在c++里变量是值语义（在JAVA、Python变量是引用语义）。因此对于赋值操作意味着内存拷贝而不是简单的赋值指针。**而右值引用的一个作用就是我们可以**通过重新利用临时变量（右值）来避免无意义的内存copy。**

```
string s0(“my mother told me that”);
string s1(“cute”);
string s2(“fluffy”);
string s3(“kittens”);
string s4(“are an essential part of a healthy diet”);

string dest = s0 + ” ” + s1 + ” ” + s2 + ” ” + s3 + ” ” + s4;
//对string求和中，每次调用operator+()都会创建一个临时变量，一共创建了8个临时的string对象。而这里真正低效的原因是，每次创建一个string对象都需要从堆上申请空间，将字符串的内容copy进来，并且这些临时的string都是只用一次。
```





通过&&获得右值引用，右值引用只能绑定右值
右值引用的好处是**减少右值作为参数传递时的复制开销**

```
type &&引用名 = 右值表达式；
```

```
int intValue = 10;
int &&intValue2 = 10;//正确，字面常量是右值
int &&intValue3 = intValue;//错误 intvalue是左值，字面常量是右值
```

使用**std::move**可以获得绑定到一个左值的右值引用

```
	int intValue = 10;
	int &&intValue3 = std::move(intValue);
```



