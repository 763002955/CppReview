# lambda表达式（匿名函数）

**为什么使用lambda表达式？** 

C++往往会大量用到函数对象，为此要编写很多函数对象类。有的函数对象类只用来定义了一个对象，而且这个对象也只使用了一次，编写这样的函数对象类就有点浪费。而且，定义函数对象类的地方和使用函数对象的地方可能相隔较远，看到函数对象，想要查看其 operator() 成员函数到底是做什么的也会比较麻烦。

```
例如：
struct print{
	void operator()(int element)
	{
		cout << element << endl; 
	}
};
int main(void){
	std::vector<int> v = {1, 2, 3, 4, 5};
	std::for_each(v.begin(), v.end(), print());
	return0;
}

如果你只是在特定的地方使用一次print，那么编写了完整的一个print就显得多余了。
对于只使用一次的函数对象类，能否直接在使用它的地方定义呢？
对于上面的这种情形，使用内联代码会更合适，这可以通过Lambda函数来实现，如下所示：
std:for_each(v.begin(), v.end(), [](int element) 
{ cout << element << endl; });
```



lambda表达式是**形如auto f = [ ]{ }的函数。有函数体，没有函数名。**C++ 11 中用于**定义并创建匿名的函数对象**，以简化编程工作。

```
[captures] (params) mutable-> type{...} 
//lambda 表达式的完整形式
```

[captures] ：捕获外部变量

不能省略，函数对象参数是传递给编译器自动生成的函数对象类的构造函数的。

| **[]**       | **无捕获**                                                   |
| ------------ | ------------------------------------------------------------ |
| **[=]**      | **传值拷贝的方式捕获所有外部变量，函数体内可以访问，但是不能修改。** |
| **[&]**      | **引用的方式捕获所有外部变量，函数体内可以访问并修改（需要当心无效的引用）；** |
| **[var]**    | **以值（拷贝）的方式捕获某个外部变量，函数体可以访问但不能修改。** |
| **[&var]**   | **以引用的方式获取某个外部变量，函数体可以访问并修改**       |
| **[this]**   | **捕获this指针，可以访问类的成员变量和函数**                 |
| **[=,&var]** | **引用捕获变量var，其他外部变量使用值捕获。**                |
| **[&.var]**  | **只捕获变量var，其他外部变量使用引用捕获。**                |

举例说明：

```
int x=0,y=0;
auto f1 = [=](){ return x; };  //以传值方式捕获使用变量，不能修改
auto f2 = [&](){ return ++x; }; //以引用方式捕获所有变量，可以修改，但要当心引用无效 函数内部x值为0，之后变为1，y没有被修改，值仍然是0；
auto f3 = [x](){ return x; }; //以值方式捕获x，不能修改，函数内部x值仍然为0
auto f4 = [x,&y](){ y += x; };//以值方式捕获x，以引用方式捕获y，y可以修改，x,y均是0，运算后y仍然是0；
auto f5 = [&,y](){ x += y;}; //以引用方式捕获y之外所有变量，y不能修改
auto f6 = [&](){ y += ++x;};  //以引用方式捕获所有变量，可以修改，
auto f7 = [](){ return x ;}; //无捕获，不能使用外部变量，编译错误
```

值得注意的是**变化的捕获发生在了lambda表达式的声明之时，如果使用值方式捕获，即使之后变量的值发生变化，lambda表达式也不会感知，仍然使用最初的值。**如果想要使用外部变量的最新值就必须使用引用的捕获方式，但也需要当心变量的生命周期，防止引用失效。

```
int a[4] = {11, 2, 33, 4};
sort(a, a+4, [=](int x, int y) -> bool { return x%10 < y%10; } );
for_each(a, a+4, [=](int x) { cout << x << " ";} );

这段程序的输出结果为：11 2 33 4

第二行：将数组a按个位数大小从小到大排序
第三行：按序打印
```

```
int a[4] = { 1, 2, 3, 4 };
int total = 0;
for_each(a, a + 4, [&](int & x) { total += x; x *= 2; });
cout << total << endl;  //输出 10
for_each(a, a + 4, [=](int x) { cout << x << " "; });

输出结果为：
10 
2 4 6 8
第三行： int &x 中x为遍历数组时每个数
```

```
int main()
{   
    int x = 100,y=200,z=300;
    auto ff  = [=,&y,&z](int n) {
        cout <<x << endl;
        y++; z++;
        return n*n;
    };
    cout << ff(15) << endl;
    cout << y << "," << z << endl;
}

输出结果为：
100
225
201 301
```



**mutable 或 exception 声明**

这部分可以省略。按值传递函数对象参数时，加上 mutable 修饰符后，可以修改传递进来的拷贝（**注意是能修改拷贝，而不是值本身**）。exception 声明用于指定函数抛出的异常，如抛出整数类型的异常，可以使用 throw(int)。

